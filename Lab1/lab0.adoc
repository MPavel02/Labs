:imagesdir: Images
:figure-caption: Рисунок

== Лабораторная №0
=== Задание
Создать проект  *Lab1* под микроконтроллер *STM32F411RE* в IDE *IAR Embedded Workbench*, затем написать код программы, которая считает сумму двух *char* чисел (например *1* и *-6*, *10* и *250*).

=== Создадим проект в IAR Workbench
* Создадим новый проект Project => Create New Project (рисунок 1).

.Создание нового проекта
image::img1.png[]

=== Выберем шаблон проекта
* ProjectTemplates: C++ => main (рисунок 2).

.Выбор шаблона проекта
image::img2.png[]

=== Выберем микроконтроллер
* Сохраним проект под любым именем, например project1.
* В свойствах проекта выберем модель микроконтроллера ST => STM32F4 => STM32F411 => ST STM32F411RE (рисунок 3). Для этого правой кнопкой мыши щелкнем по проекту, выберем Options и далее в категории General Option выберем вкладку Target.

.Выбор модели микроконтроллера
image::img3.png[]

=== Код программы
Напишем код программы, которая считает сумму двух *char* чисел (*1* и *-6*, *10* и *250*). Код программы, представленный на рисунке 4, будет записан в функцию main - функцию, с которой начинается программа.

.Код программы
image::img4.png[]

=== Запуск программы в режиме отладки
После создания проекта необходимо сохранить так называемое рабочее пространство или (workspace).

В рабочее пространство можно загружать несколько проектов и переключаться между проектами по мере необходимости.

После того, как проект сделан, и имеет вид показанный на рисунке 5, можно попробовать собрать проект, нажав кнопку *Ctrl+F7*, а затем загрузить полученный бинарный файл в микропроцессор и запустить на отладку с помощью кнопки *Ctrl+D*.

Все тоже самое можно сделать и с помощью кнопок быстрого доступа на панели инструментов, через меню среды или контекстное меню проекта (загрузить которое можно нажав на правую клавишу мыши на проекте).

.Вид созданного проекта
image::img5.png[]

При нажатии на кнопку *F9* мы зададим точку остановки. Точки остановки нужны для того, чтобы проверить код на правильность написания. Например, если в программе происходит сбой и мы не знаем где он, то лучше всего поставить точку остановки и проитись по коду до ошибки и узнать в чем дело. В режиме отладки можно переключать каждый шаг программы с помощью кнопок *F10*, *F11*. Клавиша *F10* продолжает выполнение отладчика без захода в функции или методы в коде приложения (код продолжает выполняться). Нажав клавишу *F10*, есть возможность обойти код, который нас не интересует. Так можно быстро перейти к важному для нас коду.

=== Вывод результата в Terminal I/O
*Terminal I/O* - это подобие консоли, в которой можно наблюдать за результатом вывода программы. Чтобы отобразить окно Terminal I/O необходимо запустить код в режиме отладки *Ctrl+D* и затем в окне *View* выбрать *Terminal I/O* (рисунок 6).

.Подключение окна Terminal I/O
image::img6.png[]

Запустим код в режиме отладки и проверим результат нашей программы в окне *Terminal I/O* (рисунок 7). При нажатии на *F5* произойдет выполнение программы.

.Вывод результатов в окне Terminal I/O
image::img7.png[]

Полученные результаты объясняются тем, что переменная *char* - 8-битное число, то есть ее вместимость 256 символов от 0 до 255. При сложении 1 + (-6) получаем число равное -5, но в переменной *char* такого числа нет и она идет с конца, то есть мы получаем число 251. При суммировании чисел 10 и 250 полученный результат объясняется тем же самым, что *char* вмещает всего 256 символов и поэтому произошло переполнение переменной и всё началось сначала. То есть 250 + 10 = 255 + 5. Пятый элемент от 0 до 255 это 4.

=== Запуск проекта в режим симуляции
По умолчанию загрузка и отладка бинарного файла осуществляется в симулятор выбранного микроконтроллера. Поэтому, если мы выполнили все верно, то должно получиться нечто похожее, показанное на рисунке 8.

.Проект в режиме отладки
image::img8.png[]

На этом рисунке можено увидеть, как сам код написанный на С++, так и окно дизассемблера, показывающее как компилятор преобразовал код в команды ассемблера. Зеленая строчка показывает текущую исполняющую строчку вашего кода и команду ассемблера. При нажатии на кнопку *F10* или *F11* мы переходим наже как по строчкам кода, так и по окну дизассемблера и можем в нем определять где создались наши переменные.

Для того чтобы остановить отладку и выйти в режим разработки необходимо нажать кнопки Ctrl+Shift+D.

=== Окна Watch и Registers
Для того, чтобы просмотреть как изменяются переменные на пути всего когда можно использовать окно *Watch*, которое можно открыть в режиме отладки во вкладке *View* (рисунок 9). С помощью клавиш *F10* или *F11* можно идти по коду и наблюдать изменение значений переменных в окне Watch.

.Просмотр переменных в окне Watch
image::img9.png[]

В окне *Registers* можно просматривать значения регистров в которых созданы переменные (при условии, что они там созданы). Чтобы это окно нужно нажать в режиме отладки во вкладке *View* на строчку *Registers* (рисунок 10).

.Просмотр регистров в окне Registers
image::img10.png[]

Аналогично окну *Watch* можно просматривать изменение регистров пройдясь по коду клавишами *F10* или *F11*.

====
*Ответы на вопросы первого раздела*

[qanda]
Дайте определение понятию “Интегрированной среде разработки”::
Ответ:
Что такое компилятор и чем он отличается от транслятора?::
Ответ:
Что такое компоновщик и какие функции он выполняет?::
Ответ:
Почему важен процесс проектирования ПО какие задачи входят в этот процесс?::
Ответ:
Дорисуйте процесс разработки ПО, описанный на изображении *IAR_Workbench* с учетом итеративности связей в этом процессе::
Ответ:
Зачем нужная отладка и в каких случаях она применяется? Для чего применяются точки остановки?::
Ответ:
Какие еще важные IAR workbench можно добавить в таблицу *Характеристики IAR*::
Ответ:



