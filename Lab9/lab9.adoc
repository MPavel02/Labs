:imagesdir: Images
:figure-caption: Рисунок

== Лабораторная работа №9
=== Задание
--
Настроить и подключить *аналого-цифровой преобразователь (АЦП)* и вывести значения температуры с термометра *АЦП* по инжекторному каналу. Значения температуры отобразить в программе *Terminal* через порт *USART*.
--
=== 1. Вывод комнатной температуры с АЦП
Для начала дадим определение *АЦП*.

*Аналого-цифровое преобразование* – это процесс преобразования входной физической величины в ее числовое представление.

*Аналого-цифровой преобразователь (АЦП)* – устройство, выполняющее такое преобразование. Формально, входной величиной *АЦП* может быть любая физическая величина – напряжение, ток, сопротивление, емкость, частота следования импульсов, угол поворота вала и т.п.

Далее необходимо настроить *АЦП*.
Листинг кода настройки *АЦП* приведен ниже.
[source,c]
----
   //********* ADC1 настройка (ADC1 - аналого-цифровой преобразователь)
   //Переключение на частоту ADC1

   RCC::APB2ENR::ADC1EN::Enable::Set();

   //Переключение на температурный сенсор

   ADC_Common::CCR::TSVREFE::Enable::Set();

   //Установка режима одиночного преобразования

   ADC1::CR1::RES::Bits12::Set();
   ADC1::CR2::CONT::SingleConversion::Set();
   ADC1::CR2::EOCS::SingleConversion::Set();

   // Установка частоты диспретизации в 84 цикла для 18 канала, так как согласно документации напряжение температурного сенсора передается на 18 канал (рисунок 1).

   ADC1::SMPR1::SMP18::Cycles84::Set();

   // Установка длины последовательного преобразования на 1

   ADC1::SQR1::L::Conversions1::Set();

   // Установка первого преобразования на 18 канал

   ADC1::SQR3::SQ1::Set(18);
----

.Блок схема температурного сенсора
image::img1.png[]

Следующим шагом необходимо получить код с *АЦП* и преобразовать данный код в температуру. В документации присутствует формула, по которой можно расчитать температуру при помощи кода АЦП (рисунок 2).

.Описание использования температурного сенсора
image::img2.png[]

Температура определяется по некоторой прямой

y = k*x + b,

где y - комнатная температура, определенная температурным сенсором; x - код, полученный с *АЦП* (максимум 4096); k - угол наклона прямой; b - смещение по оси y.

Для расчета коэффициентов k и b воспользуемся Datasheet на плату STM32F411Re (рисунок 3).

.Характеристики температурного сенсора
image::img3.png[]

По данным на рисунке 3 можно расчитать коэффициенты k и b:
[source,c]
----
constexpr float B1 = (25.0F - 0.76F/0.0025F);
constexpr float K1 = (3.3F/4095.0F)/0.0025F;
----

Далее выведем температуру в *Terminal IAr'а*:
--
1. включим *АЦП*;
2. запустим преобразование на регулярном канале;
3. дождемся пока преобразование не завершится;
4. получим код с *АЦП*;
5. с помощью формулы преобразуем код в температуру и выведем в Terminal.
--

Листинг кода функции *main* представлен ниже:
[source,c]
----
int main(void)
{
  std::uint32_t data = 0U;

  // Включим ADC1

  ADC1::CR2::ADON::Set(1);

  for(;;)
  {
    //**************ADC*****************

    //Запуск преобразования на регулярном канале

    ADC1::CR2::SWSTART::On::Set();

    // дожидаемся пока преобразование не завершится
    while(ADC1::SR::EOC::ConversionNotComplete::IsSet())
    {
    }

    //Получаем код с ADC

    data = ADC1::DR::Get(); //Get data from ADC;

    //Преобразуем АЦП код в температуру и выводим в Terminal

    std::cout << "Count: " << data << " Temperature_C: " << static_cast<float>(data) * K1 + B1 << std::endl;

    temp = std::to_string(static_cast<float>(data) * K1 + B1);
  }
}
----

Результат выполнения представлен на рисунке 4.

.Результат выполнения программы (вывод комнатной температуры)
image::img4.png[]

По полученным данным можно сказать, что комнатная температура в районе 23 градусов цельсия.

Также можно получить более точную температуру, расчитав ее по температурным точкам, которые разработчик платы заложил в код. На рисунке 3 в таблице 72 приведены адреса памяти к которым можно обратиться и получить более точные (откалиброванные) значения с *АЦП*. Преобразуем получение температуры с *АЦП* согласно данным точкам и выведем 2 различных температуры в терминал. Первая температура, не откалиброванная будет обозначаться *Temperature_C*, а откалибровання *Temperature_calib*.

Листинг кода функции *main* представлен ниже:
[source,c]
----
int main(void)
{
  std::uint32_t data = 0U;

  // Для откалиброванной температуры

  float Temperature_calib = 0.0F;
  uint16_t *CAL1 = (uint16_t *)0x1FFF7A2C;
  uint16_t *CAL2 = (uint16_t *)0x1FFF7A2E;

  // Включим ADC1

  ADC1::CR2::ADON::Set(1);

  for(;;)
  {
    //**************ADC*****************

    //Запуск преобразования на регулярном канале

    ADC1::CR2::SWSTART::On::Set();

    // дожидаемся пока преобразование не завершится
    while(ADC1::SR::EOC::ConversionNotComplete::IsSet())
    {
    }

    //Получаем код с ADC

    data = ADC1::DR::Get(); //Get data from ADC;

    //Преобразуем АЦП код в температуру и выводим в Terminal

    std::cout << "Count: " << data << " Temperature_C: " << static_cast<float>(data) * K1 + B1 << std::endl;

    // Для откалиброванных значений

    Temperature_calib = (((float)(110-30)/(*CAL2-*CAL1)*((float)data - *CAL1))+30);

    std::cout << "Count: " << data << " Temperature_calib: " << Temperature_calib << std::endl;

  }
}
----

Результат выполнения представлен на рисунке 5.

.Результат выполнения программы (вывод комнатной неоткалиброванной и откалиброванной температуры)
image::img5.png[]

В дальнейшем будем использовать откалиброванную температуру.