:imagesdir: Images
:figure-caption: Рисунок

== Лабораторная работа №4
=== Задание
--
Написать программу, *которая моргает всеми 4 светодиодами*, но без использования GPIOA::ODR::ODR5::High::Set() и тому подобное, а только прямой доступ к памяти по адресам.
--
=== 1. Код программы
Откроем проект *Lab1* как в лабораторной работе №2, настроим проект, подключим плату и проверим, что всё работает. Для того, чтобы реализовать мограние всех 4 светодиодов необходимо подключить библиотеки портов A и C.

Код представлен ниже:

[source,c]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" //for Gpioa
#include "gpiocregisters.hpp" //for Gpioc
----

Для того, чтобы использовать прямой доступ по адресам необходимо воспользоваться *указателями* они образуются с помощью * и указывают на адрес переменной.

Запишем код для моргания всех 4 светодиодов:

[source,c]
----
int main()
{
    //Подать тактирование на порт А
    RCC::AHB1ENR::GPIOAEN::Enable::Set();
    //Подать тактирование на порт C
    RCC::AHB1ENR::GPIOCEN::Enable::Set();
    //Порта A. 5 на вывод
    GPIOA::MODER::MODER5::Output::Set();
    //Порта C.5, C.8, C.9 на вывод
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();

    for(;;)
    {
        uint32_t* ptrPaOdr = reinterpret_cast<uint32_t*>(0x40020014);

        *ptrPaOdr ^= static_cast<uint32_t>(1 << 5);

        //1 << 5 = 000000b | 000010000b = 000010000b

        /*
        *ptrPaOdr |= static_cast<uint32_t>(1 << 5);
        *ptrPaOdr &=~ static_cast<uint32_t>(1 << 5);
        */

        uint32_t* ptrPcOdr = reinterpret_cast<uint32_t*>(0x40020814);

        *ptrPcOdr ^= static_cast<uint32_t>(1 << 5);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 9);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 8);


        delay(1000000);
        *ptrPaOdr ^= static_cast<uint32_t>(1 << 5);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 5);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 9);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 8);
        delay(1000000);
    }

    return 1;
}
----

Адрес *0x40020014*, который указан в первой строчке цикла *for* нужен для того, чтобы работать с линией *GPIOA*. Этот адрес можно получить путем следующим путем:
--
*1.* Нажать правой кнопокой мыши по слову *ODR* в строчке *GPIOA::ODR::ODR5::High::Set()* и выбрать из списка *Go to Definition of "ODR"* как показано на рисунке 1:

.Переход к адресу линии *GPIOA*
image::img1.png[]

*2.* Прочитать адрес выведенный снизу в окне программы для подлкюченных библиотек (рисунок 2).

.Окно *Ambiguous Definitions*
image::img2.png[]

В данном окне показаны два адреса на линии A и C. Они нам понадобятся для включения светодиодов через указатели.

Функция *delay* аналогична функции из лабораторной №3. Конструкция *reinterpret_cast* преобразует типы, несовместимыми друг с другом. К примеру в первой строчке цикла *for* данная конструкция преобразует адрес 0x40020014 в указатель типа uint32_t. Во второй строчке цикла *for* мы сдвигаем *единицу* на 5 позиций влево, чтобы подключить пятый порт линии А с помощью операции *или не*, которая обозначается ^. Затем мы также используя операцию *или не* выключаем светодиод возвращая единицу обратно. В комментарии представлено такое же включение и выключение светодиода, но только уже с использованием операций *или* |, а затем *и не* & ~.

Также проделываем для линии C, но только чтобы включить порты C8 и C9 необходимо сдвигать 1 на 8 и 9 позиций влево.

Поставим точку остановки напротив второй строчки цикла *for* и запустим программу, а затем включим окно *Registers* (рисунок 3). Также выберем в строке *Group* линию *GPIOA* и отроем строчку *ODR*.

.Окно *Registers* с выключенным светодиодом *ODR5*
image::img3.png[]

Видим, что напротив *ODR5* стоит 0. Это означает, что светодиод не горит, на плате это видно. Нажмем *F10* и перейдем к следующей строке (рисунок 4).

.Окно *Registers* с включенным светодиодом *ODR5*
image::img4.png[]

На рисунке 4 показано, что напротив *ODR5* стоит 1 это означает, что светодиод горит, на плате это видно. Чтобы также увидеть то, что загораются светодиоды и на линии *GPIOC* нужно в поле *Group* выбрать *GPIOC*.

Уберем точку остановки и запустим программу, покажем действие на плате (рисунок 5).

.Реализация кода на плате
image::gif1.gif[]