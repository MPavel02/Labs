:imagesdir: Images
:table-caption: Таблица
:figure-caption: Рисунок
:toc:
:toc-title: ОГЛАВЛЕНИЕ:

== Требования к ПО
--
Авторы работы: Нефедова А.В., Маскаль П.И. гр. КЭ-413.
--
=== Задание к курсовой работе (вариант 8)
--
image::img1.png[]
image::img2.png[]

--
=== 1. Переменный резистор

*Переменный резистор* (или *потенциометр*) - это резистор, у которого электрическое сопротивление между подвижным контактом и выводами резистивного элемента можно изменять механическим способом.

Снимаемое с подвижного отводного контакта потенциометра напряжение может изменяться от нуля до максимального значения, равного приложенному к потенциометру напряжению, в зависимости от текущего положения подвижного контакта.

Величина снимаемого напряжения может как линейно зависеть от перемещения движка, так и логарифмически, поэтому потенциометры подразделяются на *линейные* и *логарифмические*.

.Схема работы переменного резистора
image::img3.png[]

Согласно схеме платы расширения переменный резистор находится на линии *PA0* и имеет номинал *10 кОм*.

.Потенциометр на схеме
image::img4.png[]

Предположим, что на нашей плате стоит переменный резистор с линейной функцией преобразования. Тогда используя точный мультиметр измерим напряжение и затем по формуле для расчета напряжения, которая приведена ниже определим точное напряжение по двум точкам.

Формула для расчета напряжения, получаемого с АЦП:

image::img5.png[]

image::img10.png[]

Коэффициент _k_ рассчитается по следующей формуле:

_k_ = (_maxVoltage_ - _minVoltage_)/(_maxCode_ - _minCode_).

Коэффициент _b_ рассчитается по следующей формуле:

_b_ = _minVoltage_ - _minCode_ * (_maxVoltage_ - _minVoltage_)/(_maxCode_ - _minCode_).

=== 2. Аналого-цифровой преобразователь

*Аналого-цифровой преобразователь* – устройство, которое принимает аналоговые сигналы и генерирует соответствующий им цифровой код, пригодный для дальнейшей обработки микропроцессором или другим цифровым устройством.

Сперва АЦП преобразует аналоговый сигнал в дискретный, чтобы разбить измеряемый диапазон на какое-то конечное количество значений. Такой процесс называется *квантованием*.

*Основными характеристиками* АЦП можно назвать *частоту преобразования*, которая выражается в отсчетах в секунду (samples per second) и *разрядность* (количество шагов) – в битах.

Почти во всех микроконтроллерах STM32, АЦП выполнено по схеме 12-битного АЦП последовательного приближения (SAR ADC), структурная схема которая показана на рисунке 3.

.Структурная схема АЦП последовательного приближения
image::img6.png[]

* Он включает в себя компаратор, регистр последовательного приближения (SAR), цифро-аналоговый преобразователь (ЦАП).
* Регистр последовательного приближения осуществляет алгоритм последовательного приближения, генерируя текущее значение кода, подающегося на вход ЦАП, на основе которого ЦАП генерирует выходное напряжение.
* Компаратор сравнивает значение входного сигнала с сигналом выхода ЦАП.
Данный вид преобразователя измеряет величину входного сигнала, осуществляя ряд последовательных «взвешиваний» (сравнений) измеряемой величины с 1/2, 1/4, 1/8, и т.д. от ее возможного максимального значения.
* Допустим, что сигнал находится в интервале (0 – Uоп), тогда с приходом первого тактового импульса регистра последовательного приближения на выходе встроенного ЦАП устанавливается величина, равная половине Uоп. Если сигнал превышает эту величину, тогда его сравнивают с напряжением 3/4 Uоп, которое находится посередине оставшегося интервала. Если сигнал меньше установленного уровня, то следующее сравнение будет производиться с меньшей половиной оставшегося интервала (т.е. с уровнем 1/4 Uоп). Такое сравнение повторяется N раз и на выходе получается N бит результата.

*Основные параметры АЦП*, используемого в данной работе:

* Напряжение питания: *Vdd* = 1,7 - 3,6 В (стндартное значение Vdd = 3,3 В);
* Опорное напряжение: *Vref* = 1,7 - Vdd;

.Точность АЦП для 30 МГц
[options="header"]
|=====================
|Обозначение|Параметр                          |Значение        |Единицы измерения
|ET         |Общая нескорректированная ошибка  |От ±2 до ±5     |LSB
|EO         |Ошибка смещения                   |От ±1,5 до ±2,5 |LSB
|EG         |Ошибка усиления                   |От ±1,5 до ±4   |LSB
|ED         |Ошибка дифференциальной линейности|От ±1 до ±2     |LSB
|EL         |Ошибка интегральной линейности    |От ±1,5 до ±3   |LSB
|=====================

.Характеристика точности АЦП
image::img7.png[]

* Основную часть погрешности преобразования аналогового сигнала в цифровой код составляет погрешность АЦП, которая определяется погрешностью квантования. Погрешность квантования равна весу младшего разряда и вычисляется по формуле:

image::img9.png[]

* Определим погрешность квантования

image::img8.png[]

* Определим приведенную погрешность АЦП:

image::img11.png[]

=== 3. Механизм DMA для получения кода измерения

Прямой доступ к памяти (DMA) используется для обеспечения высокоскоростной передачи данных между периферийными устройствами и памятью.

Каждая передача DMA состоит из трех операций:

* Загрузка данных из регистра периферийного модуля или адреса в
памяти через внутренний регистр.
* Сохранение данных, загруженных во внутренний регистр в
указанное место. Им может быть периферийный модуль или адрес
в памяти.
* Увеличение адресов источника и приемника при необходимости.


Наше устройство оснащено двумя двухпортовыми DMA общего назначения (DMA1 и DMA2) с 8 каналами каждый. Оба канала DMA сидят на шине AHB1 и перед тем как начать с ним работать надо на него подать тактирование, подняв биты DMA1EN и DMA2EN в регистре RCC_AHB1ENR

image::img13.png[]

Затем, после подачи тактирования необходимо выбрать канал, которому соответствует АЦП. Согласно рисунку 5 это канал 0 и поток 0 периферии DMA2.

.Таблица каналов DMA2
image::img12.png[]

Выбор канала осуществляется с помощью регистра CR в нем CHSEL.

image::img18.png[]

Следующим шагом копируем данные из АЦП путем подключения регистра PAR.

image::img19.png[]

Затем необходимо задать адрес буфера, куда копируем данные с помощью регистра M0AR.

image::img20.png[]

Определяем направление передачи данных по регистру CR и в нем по DIR. В нашем случае из периферии в память.

image::img21.png[]

Не изменяем адрес периферии, всё время копируем только из ADC1. Для этого используем регистр CR и в нем PINC.

image::img22.png[]

Адрес памяти изменяем, чтобы каждое новое значение записывалось в следующий элемент массива буфера. Делаем это по регистру CR и в нем MINC.

image::img23.png[]

Устанавливаем размер данных буфера 16 бит по регистру CR и в нем MSIZE.

image::img24.png[]

Затем можно включить циклический режим, т.е. после того как буфер наполнится, он продолжит наполняться с первого элемента, естественно старые данные затрутся. Регистр CR в нем CIRC.

image::img25.png[]

Устанавливаем высокий приоритет по регистру CR в нем PL.

Отключаем режим FIFO. Регистр FCR.

image::img26.png[]

Устанавливаем размер данных периферии 16 бит по регистру CR и в нем PSIZE.

Устанавливаем пакетную пересылку по памяти и по периферии в одиночный Single режим по регистру CR и в нем MBURST и PBURST.

Затем запускаем DMA по регистру CR и в нем записываем бит EN.


=== 4. Период измерения

В задании на курсовую работу указан период измерения 50 ms, его можно задать с помощью систем реального времени, которые будут представлены ниже, а именно функции Sleep().

Но так как у нас в программе присутствует фильтр, то нам необходимо согласовать время у фильтра и период измерения. В фильтре dt = 100 миллисекунд, поэтому период измерения сделаем 100 миллисекунд.

=== 5. Цифровой фильтр

В задании нужно реализовать фильтр с бесконечной импульсной характеристикой (БИХ), для которого создадим новый класс с входной и выходной величиной.

Фильтры с бесконечной импульсной характеристикой (БИХ) относятся к рекурсивным фильтрам и вычисляют выходной сигнал на основании значений предыдущих входных и выходных отсчётов. Теоретически, импульсная характеристика БИХ-фильтра никогда не достигает нуля, поэтому выход получается бесконечным по длительности.

Из преимуществ БИХ-фильтров можно отметить:

* относительную простоту реализации;
* относительную простоту синтеза на основе аналоговых прототипов.

В качестве недостатков:

* могут быть неустойчивыми. Если коэффициент в цепи обратной связи будет больше единицы, может образоваться положительная обратная связь, фильтр может завестись, и сигнал на его выходе может продолжаться и усиливаться даже после выключения входного воздействия;
* они не могут обладать линейной фазой;
* мы не можем сформировать произвольную АЧХ и ФЧХ, по сути, мы выбираем АЧХ из типов, основывающихся на аналоговых прототипах, чаще всего это стандартные фильтры нижних и верхних частот, полосовые и так далее. Частотно-избирательные фильтры, с полосами пропускания и заграждения и без какого-либо контроля над фазой сигнала.

Синтезируются БИХ-фильтры при помощи преобразования непрерывной передаточной характеристики аналогового прототипа в дискретную характеристику цифрового фильтра.

image::img14.png[]

=== 6. Передача значений по беспроводному интерфейсу Bluetooth Bee HC-06

*Bluetooth* – это спецификация беспроводных персональных сетей (стандарт IEEE 802.15.1). Принцип действия основан на использовании радиоволн. Радиосвязь Bluetooth осуществляется в ISM-диапазоне, который используется в различных бытовых приборах и беспроводных сетях (свободный от лицензирования диапазон 2,4-2,4835 ГГц).

Основными преимуществами Bluetooth по сравнению с конкурирующими решениями являются низкий уровень энергопотребления и невысокая стоимость приемопередатчиков, что позволяет применять его даже в малогабаритных устройствах с миниатюрными элементами питания.

Основная функция модуля *Bluetooth* - это организация связи по
последовательному интерфейсу там, где ранее для связи применялась кабельная
линия.

Чтобы реализовать беспроводную передачу данных с помощью модуля Bluetooth Bee HC-06 воспользуемся платой расширения Accessory Shield.

В плату интегрированы: джойстик, потенциометр, зуммер, RGB светодиод, температурный датчик, трехосевой цифровой акселерометр, прецизионные часы реального времени (RTC), дисплей 0.96 inch OLED и разъем интерфейса XBee для подключения беспроводных модулей.

image::img27.png[]

--
1. Разъем расширения Arduino: для подключения плат Arduino

2. Разъемы XBee: для подключения беспроводных модулей XBee

3. 0.96inch OLED: разрешение 128x64

4. RGB светодиод

5. Зуммер

6. Потенциометр 10K

7. ADXL345: 3-осевой цифровой акселерометр, измерения в диапазоне до ±16g

8. LM75BDP: температурный датчик, разрешение до 0.125 ℃

9. Джойстик: 5 направлений

10. Индикатор состояния модуля XBee

11. Индикатор питания

12. EASYLINK модуля XBee

13. Кнопка сброса модулей XBee и Arduino

14. Чип DS3231 презиционных часов реального времени (RTC)

15. Держатель батареи CR1220 для RTC

16. P9813 драйвер RGB светодиода

17. Джампер выбора режима Отладка/Связь
--

* При соединении TXD и TX, RXD и RX, соответственно, возможны режимы отладка/конфигурирование модуля XBee через последовательный порт Arduino с использованием программного обеспечения хост компьютера.

* При соединении TXD и RX, RXD и TX, соответственно, возможен режим связи с модулем XBee через последовательный порт Arduino.

Параметры модуля *Bluetooth Bee HC-06*:

* скорость по умолчанию — 9600,
* диапазон установки — 4800 кГц - 1.3 MГц.

.Распиновка и размеры модуля *Bluetooth Bee HC-06*
image::img15.png[]

.Описание контактов
[options="header"]
|=====================
|Контакт|Описание
|PIN1   |Передача UART_TXD , уровень ТТЛ/КМОП, вывод данных UART
|PIN2   |Прием UART_RXD, уровень ТТЛ/КМОП, ввод данных UART
|PIN11  |Сброс модуля. Подача низкого уровня на контакт приведёт к сбросу.
|PIN12  |VCC, напряжение питания. Стандартный уровень напряжения составляет 3,3 В, диапазон возможных значений 3,0 - 4,2 В
|PIN13  |GND, заземление
|PIN22  |GND, заземление
|PIN24  |LED, Светодиод, индикатор рабочего режима.

Ведомое устройство: До установления связи контакт выдаёт прямоугольный сигнал с периодом в 102 мс. После установки связи контакт выдаёт высокий уровень.

Ведущее устройство: Если в памяти нет записи о соединяемом устройстве, то на выходе будет прямоугольный сигнал с периодом 110мс. Если в памяти устройство есть — период составляет 750мс.

После установления соединения контакт выдаёт высокий уровень.
|PIN26  |В случае ведущего устройства контакт обнуляет информацию о запоминаемых устройствах. После обнуления ведущее устройство будет искать ведомое случайным образом. Адрес нового устройства будет записан в память, и в следующий раз в поиске будет только оно.
|=====================

Передача происходит по интерфейсу USART2, поэтому для начала необходимо подключить перемычки по схеме платы STM32F411RE.

image::img28.png[]

Покажем на плате.

image::img29.jpg[]

Перейдем к настройке USART интерфейса:

* Необходимо первым делом подключить порт A к системе тактирования.

image::img30.png[]

* Затем назначить порты А2 и А3 на альтернативный режим работы с помощью регистра GPIOA::MODER.

image::img31.png[]

* Назначим порты А2 и А3 на альтернативную функцию 7 с помощью регистра GPIOA::AFRL.

image::img32.png[]

* Затем подключим USART2 к системе тактирования

image::img33.png[]

* С помощью регистра CR1 настраиваем USART2.

image::img34.png[]

* Используя регистр BRR настраиваем скорость передачи USART на 9600.

image::img35.png[]

* Запускаем USART2 по регистру CR1.

image::img36.png[]

=== 7. Операционные системы реального времени и C++

C++ — компилируемый, статически типизированный язык программирования общего назначения, на котором можно создавать программы любого уровня сложности.

*Операционные системы реального времени (ОСРВ)* предназначены для обеспечения интерфейса к ресурсам критических по времени систем реального времени. Основной задачей в таких системах является своевременность (timeliness) выполнения обработки данных.

*Задачей ОСРВ* является обеспечение реакции на определенное действие за отведенный квант времени. Для разных задач этот квант имеет разное значение.

Например:

* математическое моделирование - несколько микросекунд;
* радиолокация - несколько миллисекунд;
* управление производством - несколько минут.

*Временем реакции систем на события* называют интервал времени от события на объекте и до выполнения первой интструкции в программе обработки этого события.

*Интервал времени* считают от возникновения запроса на прерывание и до выполнения первой инструкции обработчика. Определяется свойствами операционной системы и архитектурой микроконтроллера.

*ОСРВ* применяют в случаях:

* если есть устройство с нетривиальной логикой синхронизации обмена данными между набором сенсоров;
* если нужно гарантировать время отклика.

*ОСРВ* не нужно применять в случае, если задача слишком тривиальна (например, получение данных с 1 сенсора, и отправлять дальше, обработать нажатие 1 кнопки и т.д.) т.к. это приведет к ненужной избыточности, как полученного кода, так и решения самой задачи.

Еще одной задачей *ОСРВ* является многозадачность.

*Многозадачность* - одновременное выполнение нескольких задач.

Существует несколько видов многозадачности:

* *Кооперативная* - следующая задача не выполнится, пока полностью не завершена предыдущая;
* *Вытесняющая* - более высоко-приоритетная задача может вытеснить менее приоритетную.

Принцип работы и запуска задачи похож на *принцип работы прерывания* (рисунок 7).

.Принцип работы прерываний
image::img16.png[]

В *ОСРВ* вместо прерываний используются задачи, которые вызываются планировщиком каждый раз по прерыванию системного таймера или при вызове планировщика.

*Задача* - это минипрограмма, которая имеет свою точку входа, и выполняется внутри бесконечного цикла и обычно не должна выходить из него. Она имеет собственный стек, приоритет, также может иметь название и идентификатор. Принцип работы задач представлен на рисунке 8.

Что можно сделать с задачей:

* можно создать;
* можно удалить;
* можно оповестить;
* активировать/деактивировать;
* перевести в режим ожидания.

.Принцип работы задач *ОСРВ*
image::img17.png[]

*Free RTOS* - бесплатная многозадачная операционная система реального времени для встраиваемых систем. Портирована на 35 микропроцессорных архитектур.

Планировщик системы очень маленький и простой, однако можно задать различные приоритеты процессов, вытесняющую и невытесняющую многозадачность, семафоры и очереди.

*Free RTOS* мала и проста. Ядро системы умещается в 3-4 файлах.

С помощью данной системы мы будем создавать задачи.

