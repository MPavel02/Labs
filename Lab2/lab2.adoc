:imagesdir: Images
:figure-caption: Рисунок

== Лабораторная работа №2
=== Задание
--
. Написать программу вычисляющую следующее выражение *-3/3U *3* и объяснить результат.
. Подключить плату к домашнему компьютеру, проверить что все работает, плата прошивается.
. Запустить на плате проект *Lab1* и добавить в *main* код для зажигания светодиодов, представленный ниже (не забыть подключить бибилиотеку GPIOA):
[source,c]
RCC::AHB1ENR::GPIOAEN::Enable::Set();
GPIOA::MODER::MODER5::Output::Set();
GPIOA::ODR::ODR5::High::Set();
. Пронаблюдать происходящее на плате и зафиксировать в виде фотографии.
--
=== 1. Код программы
Напишем код программы вычисляющий выражение *-3/3U *3* и выведем это выражение в Terminal I/O (рисунок 1, 2).

.Код программы
image::img1.png[]

.Вывод результата программы в окне Terminal I/O
image::img2.png[]

Мое предположение заключается в том, что при делении *-3* на беззнаковое *3U* выполняется операция деления беззнаковая, потому что *-3* в беззнаковом варианте (в предположении что *int* и *unsigned int* в 32-битном исполнении) это *2^32^ - 3 = 4 294 967 296 - 3 = 4 294 967 293*. При делении на *3* получим число *1 431 655 764.33*, которое получилось с остатком. На рисунке 3 показан вывод этого числа в программе.

.Вывод выражения *-3/3U* в Terminal I/O
image::img11.png[]

В программе остаток отбрасывается и если снова домножить на *3*, то получим число *4 294 967 292*, а в беззнаковом виде это *-4*.

=== 2. Подключение платы
Подключим плату к компьютеру через разъем USB. На рисунке 4 изображена плата с горящим красным огнем, это означает, что плата успешно соединена с компьютером.

.Подключенная плата
image::img10.jpg[]

=== 3. Работа с платой
==== 3.1 Проверка платы на работоспособность
Создадим пустой проект, зададим такие же настройки как и в 1 лабораторной работе (рисунок 5). В настройках проекта выберем плату *ST STM32F411RE*. Чтобы не возникало ошибки как на рисунке 6, необходимо в опциях проекта в пункте *C/C++ Compiler* в категории *List* убрать галочку с *Output assembler file* (рисунок 7).

.Пустой код
image::img4.png[]

.Ошибка при сборке проекта
image::img7.png[]

.Пункт *C/C++ Compiler* категория *List*
image::img8.png[]
Попробуем запустить проект.

Запуск прошел без ошибок (рисунок 8). Зеленый огонь говорит о том, что плата прошита успешно.

.Прошитая плата
image::img3.jpg[]

==== 3.2 Включение светодиодов на плате
Первым делом необходимо запустить проект *Lab1*, в котором находятся необходимые файлы для работы с платой. Прежде чем запускать, нужно убедиться в том, что папка с проектом находится по пути в котором нет русских букв. Например: *D:\Labs1*. Запускаем проект:

* Project => Add Existing Project (рисунок 9);

.Пункт меню проект
image::img5.png[]

* Выбираем наш проект в папке *Lab1* под названием *iarproject.ewp* и нажимаем открыть;
* Выбираем нашу плату *ST STM32F411RE* в опциях проекта;
* Уберем галочку с генерации листинга ассемблера (*Output assembler file*) в опциях проекта в пункте *C/C++ Compiler* в категории *List* как показано на рисунке 7.
* В опциях проекта в пункте *Debugger* выбираем в пункте *Driver* параметр *ST-LINK* вместо *Simulation* (рисунок 10). Это нужно для того, чтобы мы из режима симуляции платы перешли в непосредственно режим работы с самой платой;

.Выбор параметра *ST-LINK*
image::img6.png[]

* Для включения светодиода воспользуемся кодом из задания и запишем его в функцию *main*, предварительно необходимо включить библиотеки, чтобы всё работало. Код представлен ниже;

[source,c]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" //for Gpioa

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
int __low_level_init(void)
{
  //Switch on external 16 MHz oscillator
  RCC::CR::HSION::On::Set();
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {

  }
  //Switch system clock on external oscillator
  RCC::CFGR::SW::Hsi::Set();
  while (!RCC::CFGR::SWS::Hsi::IsSet())
  {

  }

  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
}
}


int main()
{
  RCC::AHB1ENR::GPIOAEN::Enable::Set();
  GPIOA::MODER::MODER5::Output::Set();
  GPIOA::ODR::ODR5::High::Set();

  return 0;
}
----

* Запустим программу и посмотрим на результат (рисунок 11).

.Плата с горящим светодиодом
image::img9.jpg[]

Диод горит => всё работает отлично.




