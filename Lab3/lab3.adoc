:imagesdir: Images
:figure-caption: Рисунок

== Лабораторная работа №3
=== Задание
--
Сделать бегущий огонь из 4 светодиодов, подключенных к портам C.5, C.8, C.9, A.5
--
=== 1. Код программы
Откроем проект *Lab1* как в лабораторной работе №2, настроим проект, подключим плату и проверим, что всё работает. Для того, чтобы реализовать бегущий огонь необходимо подключить библиотеки портов A и C.

Код представлен ниже:

[source,c]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" //for Gpioa
#include "gpiocregisters.hpp" //for Gpioc
----

Для того, чтобы бегущий огонь имел какую то нибудь задержку, чтобы светодиоды переключались необходимо реализовать функцию задержки (delay).

Код функции *delay* представлен ниже:

[source,c]
----
int delay(int cycles)
{
    for(int i = 0; i<cycles; ++i)
    {
        asm volatile("");
    }
    return 1;
}
----

Входная переменная *cycles* задает время задержки. Команда *asm volatile("");* означает пустую ассебмлерную процедуру и если тут ничего не будет, то цикл не проигнорируется.

Затем необходимо написать код фукнции *main* с включением каждого диода с некоторой заданной задержкой.

Код функции *main* представлен ниже:

[source,c]
----
int main()
{
    //Подать тактирование на порт А
    RCC::AHB1ENR::GPIOAEN::Enable::Set();
    //Подать тактирование на порт C
    RCC::AHB1ENR::GPIOCEN::Enable::Set();
    //Порта A. 5 на вывод
    GPIOA::MODER::MODER5::Output::Set();
    //Порта C.5, C.8, C.9 на вывод
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();

    for(;;)
    {
        GPIOC::ODR::ODR5::High::Set();
        delay(1000000);
        GPIOC::ODR::ODR5::Low::Set();
        delay(1000000);
        GPIOC::ODR::ODR8::High::Set();
        delay(1000000);
        GPIOC::ODR::ODR8::Low::Set();
        delay(1000000);
        GPIOC::ODR::ODR9::High::Set();
        delay(1000000);
        GPIOC::ODR::ODR9::Low::Set();
        delay(1000000);
        GPIOA::ODR::ODR5::High::Set();
        delay(1000000);
        GPIOA::ODR::ODR5::Low::Set();
        delay(1000000);
    }

    return 1;
}
----

Цикл *for(;;)* - бесконечный цикл, который постоянно включает и выключает светодиоды с задержкой по времени, заданной в функции *delay*.

В функции *main* реализован бегущий огонь с фиксируемой задержкой.

.Реализация бегущего огня на плате
image::Gif1.gif[]

.Вывод результата программы в окне Terminal I/O
image::img2.png[]

Мое предположение заключается в том, что при делении *-3* на беззнаковое *3U* выполняется операция деления беззнаковая, потому что *-3* в беззнаковом варианте (в предположении что *int* и *unsigned int* в 32-битном исполнении) это *2^32^ - 3 = 4 294 967 296 - 3 = 4 294 967 293*. При делении на *3* получим число *1 431 655 764.33*, которое получилось с остатком. На рисунке 3 показан вывод этого числа в программе.

.Вывод выражения *-3/3U* в Terminal I/O
image::img11.png[]

В программе остаток отбрасывается и если снова домножить на *3*, то получим число *4 294 967 292*, а в беззнаковом виде это *-4*.

=== 2. Подключение платы
Подключим плату к компьютеру через разъем USB. На рисунке 4 изображена плата с горящим красным огнем, это означает, что плата успешно соединена с компьютером.

.Подключенная плата
image::img10.jpg[]

=== 3. Работа с платой
==== 3.1 Проверка платы на работоспособность
Создадим пустой проект, зададим такие же настройки как и в 1 лабораторной работе (рисунок 5). В настройках проекта выберем плату *ST STM32F411RE*. Чтобы не возникало ошибки как на рисунке 6, необходимо в опциях проекта в пункте *C/C++ Compiler* в категории *List* убрать галочку с *Output assembler file* (рисунок 7).

.Пустой код
image::img4.png[]

.Ошибка при сборке проекта
image::img7.png[]

.Пункт *C/C++ Compiler* категория *List*
image::img8.png[]
Попробуем запустить проект.

Запуск прошел без ошибок (рисунок 8). Зеленый огонь говорит о том, что плата прошита успешно.

.Прошитая плата
image::img3.jpg[]

==== 3.2 Включение светодиодов на плате
Первым делом необходимо запустить проект *Lab1*, в котором находятся необходимые файлы для работы с платой. Прежде чем запускать, нужно убедиться в том, что папка с проектом находится по пути в котором нет русских букв. Например: *D:\Labs1*. Запускаем проект:

* Project => Add Existing Project (рисунок 9);

.Пункт меню проект
image::img5.png[]

* Выбираем наш проект в папке *Lab1* под названием *iarproject.ewp* и нажимаем открыть;
* Выбираем нашу плату *ST STM32F411RE* в опциях проекта;
* Уберем галочку с генерации листинга ассемблера (*Output assembler file*) в опциях проекта в пункте *C/C++ Compiler* в категории *List* как показано на рисунке 7.
* В опциях проекта в пункте *Debugger* выбираем в пункте *Driver* параметр *ST-LINK* вместо *Simulation* (рисунок 10). Это нужно для того, чтобы мы из режима симуляции платы перешли в непосредственно режим работы с самой платой;

.Выбор параметра *ST-LINK*
image::img6.png[]

* Для включения светодиода воспользуемся кодом из задания и запишем его в функцию *main*, предварительно необходимо включить библиотеки, чтобы всё работало. Код представлен ниже;

[source,c]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" //for Gpioa

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
int __low_level_init(void)
{
  //Switch on external 16 MHz oscillator
  RCC::CR::HSION::On::Set();
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {

  }
  //Switch system clock on external oscillator
  RCC::CFGR::SW::Hsi::Set();
  while (!RCC::CFGR::SWS::Hsi::IsSet())
  {

  }

  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
}
}


int main()
{
  RCC::AHB1ENR::GPIOAEN::Enable::Set();
  GPIOA::MODER::MODER5::Output::Set();
  GPIOA::ODR::ODR5::High::Set();

  return 0;
}
----

* Запустим программу и посмотрим на результат (рисунок 11).

.Плата с горящим светодиодом
image::img9.jpg[]

Диод горит => всё работает отлично.